#!/usr/bin/env python3
# Copyright 2024 Guillaume Belanger
# See LICENSE file for licensing details.

"""Kubernetes charm for Ella."""

import json
import logging
import socket
from datetime import timedelta
from ipaddress import IPv4Address
from subprocess import CalledProcessError, check_output
from typing import FrozenSet, List, Optional

from charms.kubernetes_charm_libraries.v0.multus import (
    KubernetesMultusCharmLib,
    NetworkAnnotation,
    NetworkAttachmentDefinition,
)
from charms.prometheus_k8s.v0.prometheus_scrape import (
    MetricsEndpointProvider,
)
from charms.tls_certificates_interface.v4.tls_certificates import (
    Certificate,
    PrivateKey,
    generate_ca,
    generate_certificate,
    generate_csr,
    generate_private_key,
)
from jinja2 import Environment, FileSystemLoader
from lightkube.models.meta_v1 import ObjectMeta
from ops import (
    ActiveStatus,
    BlockedStatus,
    CharmBase,
    EventBase,
    Framework,
    ModelError,
    WaitingStatus,
    main,
)
from ops.charm import CollectStatusEvent
from ops.model import SecretNotFoundError
from ops.pebble import Layer, PathError

from charm_config import CharmConfig, CharmConfigInvalidError
from kubernetes_ella import (
    AMFService,
    EBPFVolume,
)

logger = logging.getLogger(__name__)

PEER_RELATION_NAME = "core-peers"
CONFIG_TEMPLATE_DIR_PATH = "src/templates/"
CONFIG_PATH = "/etc/core"
CONFIG_FILE_PATH = "/etc/core/core.yaml"
CONFIG_TEMPLATE_NAME = "core.yaml.j2"
N2_INTERFACE_BRIDGE_NAME = "n2-br"
N3_INTERFACE_BRIDGE_NAME = "n3-br"
N6_INTERFACE_BRIDGE_NAME = "n6-br"
N2_NETWORK_ATTACHMENT_DEFINITION_NAME = "core-n2"
N3_NETWORK_ATTACHMENT_DEFINITION_NAME = "core-n3"
N6_NETWORK_ATTACHMENT_DEFINITION_NAME = "core-n6"
N3_INTERFACE_NAME = "n3"
N6_INTERFACE_NAME = "n6"
N2_INTERFACE_NAME = "n2"
N2_PORT = 38412
API_INTERFACE_NAME = "eth0"
API_PORT = 5002
XDP_ATTACH_MODE = "generic"
CA_SUBJECT = "core-ca"
CA_CERTIFICATE_JUJU_SECRET_LABEL = "self-signed-ca-certificate"


def render_config_file(
    logging_level: str,
    db_path: str,
    n2_interface: str,
    n2_port: int,
    n3_interface: str,
    n6_interface: str,
    api_interface: str,
    api_port: int,
    api_tls_cert_path: str,
    api_tls_key_path: str,
    xdp_attach_mode: str,
) -> str:
    """Render the config file.

    Returns:
        str: Content of the rendered config file.
    """
    jinja2_environment = Environment(loader=FileSystemLoader(CONFIG_TEMPLATE_DIR_PATH))
    template = jinja2_environment.get_template(CONFIG_TEMPLATE_NAME)
    content = template.render(
        logging_level=logging_level,
        db_path=db_path,
        n2_interface=n2_interface,
        n2_port=n2_port,
        n3_interface=n3_interface,
        n6_interface=n6_interface,
        api_interface=api_interface,
        api_port=api_port,
        api_tls_cert_path=api_tls_cert_path,
        api_tls_key_path=api_tls_key_path,
        xdp_attach_mode=xdp_attach_mode,
    )
    return content


def get_pod_ip() -> Optional[str]:
    """Return the pod IP using juju client."""
    try:
        ip_address = check_output(["unit-get", "private-address"])
        return str(IPv4Address(ip_address.decode().strip())) if ip_address else None
    except (CalledProcessError, ValueError):
        return None


def generate_ca_certificate() -> tuple[str, str]:
    """Generate CA certificates valid for 50 years.

    Returns:
        Tuple[str, str]: CA Private key, CA certificate
    """
    ca_private_key = generate_private_key()
    ca_certificate = generate_ca(
        private_key=ca_private_key,
        common_name=CA_SUBJECT,
        validity=timedelta(days=365 * 50),
    )
    return str(ca_private_key), str(ca_certificate)


def generate_unit_certificate(
    common_name: str,
    sans_dns: FrozenSet[str],
    ca_certificate: str,
    ca_private_key: str,
) -> tuple[str, str]:
    """Generate unit certificates valid for 50 years.

    Args:
        common_name: Common name of the certificate
        sans_ip: Subject alternative IP addresses of the certificate
        sans_dns: Subject alternative names of the certificate
        ca_certificate: CA certificate
        ca_private_key: CA private key

    Returns:
        Tuple[str, str]: Private key, Certificate
    """
    unit_private_key = generate_private_key()
    csr = generate_csr(
        private_key=unit_private_key,
        common_name=common_name,
        sans_dns=sans_dns,
    )
    unit_certificate = generate_certificate(
        ca=Certificate.from_string(ca_certificate),
        ca_private_key=PrivateKey.from_string(ca_private_key),
        csr=csr,
        validity=timedelta(days=365 * 50),
    )
    return str(unit_private_key), str(unit_certificate)


def existing_certificate_is_self_signed(ca_certificate: Certificate) -> bool:
    """Return whether the certificate is a self signed certificate generated by the Vault charm."""
    return ca_certificate.common_name == CA_SUBJECT


class EllaK8SCharm(CharmBase):
    """Charm the service."""

    def __init__(self, framework: Framework):
        super().__init__(framework)
        self._container_name = self._service_name = "core"
        self.container = self.unit.get_container(self._container_name)
        try:
            self._charm_config: CharmConfig = CharmConfig.from_charm(charm=self)
        except CharmConfigInvalidError:
            logger.error("Invalid configuration")
            return
        self._kubernetes_multus = KubernetesMultusCharmLib(
            namespace=self.model.name,
            statefulset_name=self.model.app.name,
            container_name=self._container_name,
            pod_name=self._pod_name,
            cap_net_admin=True,
            network_annotations=self._generate_network_annotations(),
            network_attachment_definitions=self._network_attachment_definitions_from_config(),
            privileged=True,
        )
        self._ebpf_volume = EBPFVolume(
            namespace=self.model.name,
            container_name=self._container_name,
            app_name=self.model.app.name,
            unit_name=self.model.unit.name,
        )
        self.amf_service = AMFService(
            namespace=self.model.name,
            name=f"{self.app.name}-external",
            app_name=self.app.name,
            ngapp_port=N2_PORT,
        )
        self._metrics_endpoint = MetricsEndpointProvider(
            self,
            jobs=[
                {
                    "static_configs": [{"targets": [f"*:{API_PORT}/api/v1/metrics"]}],
                }
            ],
        )
        self.unit.set_ports(API_PORT)
        self.framework.observe(self.on.collect_unit_status, self._on_collect_status)
        self.framework.observe(self.on.update_status, self._configure)
        self.framework.observe(self.on["core"].pebble_ready, self._configure)
        self.framework.observe(self.on.config_changed, self._configure)
        self.framework.observe(self.on.remove, self._on_remove)

    def _on_collect_status(self, event: CollectStatusEvent):
        """Handle the collect status event."""
        if not self.container.can_connect():
            event.add_status(WaitingStatus("waiting for Pebble API"))
            return
        if not self._relation_created(PEER_RELATION_NAME):
            event.add_status(WaitingStatus("Waiting for peer relation"))
            logger.info("Waiting for peer relation")
            return
        if not self.container.exists(f"{CONFIG_PATH}/cert.pem"):
            event.add_status(WaitingStatus("Waiting for certificates to be generated"))
            return
        if not self._kubernetes_multus.multus_is_available():
            event.add_status(BlockedStatus("Multus is not installed or enabled"))
            logger.info("Multus is not installed or enabled")
            return
        if not self._kubernetes_multus.is_ready():
            event.add_status(WaitingStatus("Waiting for Multus to be ready"))
            logger.info("Waiting for Multus to be ready")
            return
        if not self._config_file_is_written():
            event.add_status(WaitingStatus("waiting for config file"))
            return
        event.add_status(ActiveStatus())

    def _configure(self, _: EventBase):
        """Central configuration method.

        Most events are handled by this method. It should remain idempotent.

        It is used to:
        - Configure Kubernetes resources
        - Configure the config file
        - Configure the Pebble layer
        - Configure netorking
        """
        try:  # workaround for https://github.com/canonical/operator/issues/736
            self._charm_config: CharmConfig = CharmConfig.from_charm(charm=self)
        except CharmConfigInvalidError:
            return
        if not self.unit.is_leader():
            logger.info("Not a leader, skipping configuration")
            return
        if not self.container.can_connect():
            logger.warning("Pebble API is not ready")
            return
        if not self._kubernetes_multus.multus_is_available():
            logger.warning("Multus is not available")
            return
        self._kubernetes_multus.configure()
        self._configure_ebpf_volume()
        self._configure_amf_service()
        self._configure_self_signed_certificates()
        changed = self._configure_config_file()
        self._configure_pebble(restart=changed)

    def _on_remove(self, _: EventBase):
        self._kubernetes_multus.remove()

    def ca_certificate_secret_exists(self) -> bool:
        """Return whether CA certificate is stored in secret."""
        fields = ("privatekey", "certificate")
        try:
            secret = self.model.get_secret(label=CA_CERTIFICATE_JUJU_SECRET_LABEL)
            secret_content = secret.get_content(refresh=True)
            return all(secret_content.get(field) for field in fields)
        except (SecretNotFoundError, ModelError):
            return False

    def pull_tls_file_from_workload(self, path: str) -> str:
        """Get a file related to certs from the workload.

        Args:
            path: The path to the file in the workload

        Returns:
            str: The file content without whitespace
                Or an empty string if the file does not exist.
        """
        try:
            with self.container.pull(path) as file_content:
                return file_content.read().strip()
        except (PathError, FileNotFoundError):
            return ""

    def get_secret_content_values(
        self,
        *keys: str,
        label: str,
    ) -> tuple[str | None, ...]:
        """Get secret content values by keys.

        Args:
            keys: Keys of the requested values
            label: The secret label

        Returns:
            tuple[str | None, ...]: The secret content values,
            if a key is not found, None is returned for its value

        Raises:
            TransientJujuError
            NoSuchSecretError
            SecretRemovedError
        """
        try:
            secret = self.model.get_secret(label=label)
            secret_content = secret.get_content(refresh=True)
        except SecretNotFoundError:
            logger.error("Secret %s not found", label)
            return tuple(None for _ in keys)
        for key in keys:
            if key not in secret_content:
                logger.warning("Secret %s does not have key %s", label or id, key)
        return tuple(secret_content.get(key, None) for key in keys)

    def _configure_self_signed_certificates(self) -> None:
        """Configure the charm with self signed certificates."""
        if not self.container.can_connect():
            return
        common_name = self.get_ingress_address()
        if not common_name:
            logger.debug("No ingress address found.")
            return
        if self.unit.is_leader() and not self.ca_certificate_secret_exists():
            ca_private_key, ca_certificate = generate_ca_certificate()
            content = {
                "privatekey": ca_private_key,
                "certificate": ca_certificate,
            }
            self.app.add_secret(content, label=CA_CERTIFICATE_JUJU_SECRET_LABEL)
            logger.info("Generated CA certificate and saved it to Juju secret")
        existing_ca_certificate = self.pull_tls_file_from_workload(f"{CONFIG_PATH}/ca.pem")
        if existing_ca_certificate and existing_certificate_is_self_signed(
            ca_certificate=Certificate.from_string(existing_ca_certificate)
        ):
            logger.debug("Found existing self signed certificate in workload")
            return
        if not self.ca_certificate_secret_exists():
            logger.debug("No CA certificate found.")
            return
        ca_private_key, ca_certificate = self.get_secret_content_values(
            "privatekey",
            "certificate",
            label=CA_CERTIFICATE_JUJU_SECRET_LABEL,
        )
        if not ca_certificate:
            logger.debug("No CA certificate found.")
            return
        if not ca_private_key:
            logger.debug("No CA private key found.")
            return

        unit_private_key, unit_certificate = generate_unit_certificate(
            common_name=common_name,
            sans_dns=frozenset([socket.getfqdn()]),
            ca_certificate=ca_certificate,
            ca_private_key=ca_private_key,
        )
        self.container.push(path=f"{CONFIG_PATH}/cert.pem", source=unit_certificate)
        self.container.push(path=f"{CONFIG_PATH}/key.pem", source=unit_private_key)
        self.container.push(path=f"{CONFIG_PATH}/ca.pem", source=ca_certificate)

        logger.info("Generated and pushed unit certificates to workload")
        if self._service_is_running():
            self.container.restart(self._service_name)
            logger.info("Restarted service")

    def _service_is_running(self) -> bool:
        """Return whether the service is running."""
        try:
            return self.container.get_service(self._service_name).is_running()
        except ModelError:
            return False

    def _configure_ebpf_volume(self):
        if not self._ebpf_volume.is_created():
            self._ebpf_volume.create()

    def _configure_amf_service(self):
        if not self.amf_service.is_created():
            self.amf_service.create()

    def _configure_config_file(self):
        desired_config_file = self._generate_config_file()
        if self._is_config_update_required(desired_config_file):
            self._push_config_file(content=desired_config_file)
            return True
        return False

    def _relation_created(self, relation_name: str) -> bool:
        return bool(self.model.relations.get(relation_name))

    def _configure_pebble(self, restart=False) -> None:
        """Configure the Pebble layer.

        Args:
            restart (bool): Whether to restart the container.
        """
        plan = self.container.get_plan()
        if plan.services != self._pebble_layer.services:
            self.container.add_layer(self._service_name, self._pebble_layer, combine=True)
            self.container.replan()
            logger.info("New layer added: %s", self._pebble_layer)
        if restart:
            self.container.restart(self._service_name)
            logger.info("Restarted container ")
            return
        self.container.replan()

    def _generate_network_annotations(self) -> List[NetworkAnnotation]:
        n2_network_annotation = NetworkAnnotation(
            name=N2_NETWORK_ATTACHMENT_DEFINITION_NAME,
            interface=N2_INTERFACE_NAME,
        )
        n3_network_annotation = NetworkAnnotation(
            name=N3_NETWORK_ATTACHMENT_DEFINITION_NAME,
            interface=N3_INTERFACE_NAME,
        )
        n6_network_annotation = NetworkAnnotation(
            name=N6_NETWORK_ATTACHMENT_DEFINITION_NAME,
            interface=N6_INTERFACE_NAME,
        )
        return [n2_network_annotation, n3_network_annotation, n6_network_annotation]

    def _network_attachment_definitions_from_config(self) -> List[NetworkAttachmentDefinition]:
        n2_nad_config = {
            "cniVersion": "0.3.1",
            "ipam": {
                "type": "static",
                "addresses": [
                    {"address": self._charm_config.n2_ip},
                ],
            },
            "capabilities": {"mac": True},
            "type": "bridge",
            "bridge": N2_INTERFACE_BRIDGE_NAME,
        }
        n3_nad_config = {
            "cniVersion": "0.3.1",
            "ipam": {
                "type": "static",
                "addresses": [
                    {"address": self._charm_config.n3_ip},
                ],
            },
            "capabilities": {"mac": True},
            "type": "bridge",
            "bridge": N3_INTERFACE_BRIDGE_NAME,
        }
        n6_nad_config = {
            "cniVersion": "0.3.1",
            "ipam": {
                "type": "static",
                "addresses": [
                    {"address": self._charm_config.n6_ip},
                ],
            },
            "capabilities": {"mac": True},
            "type": "bridge",
            "bridge": N6_INTERFACE_BRIDGE_NAME,
        }
        n2_nad = NetworkAttachmentDefinition(
            metadata=ObjectMeta(name=(N2_NETWORK_ATTACHMENT_DEFINITION_NAME)),
            spec={"config": json.dumps(n2_nad_config)},
        )
        n3_nad = NetworkAttachmentDefinition(
            metadata=ObjectMeta(name=(N3_NETWORK_ATTACHMENT_DEFINITION_NAME)),
            spec={"config": json.dumps(n3_nad_config)},
        )
        n6_nad = NetworkAttachmentDefinition(
            metadata=ObjectMeta(name=(N6_NETWORK_ATTACHMENT_DEFINITION_NAME)),
            spec={"config": json.dumps(n6_nad_config)},
        )
        return [n2_nad, n3_nad, n6_nad]

    def _generate_config_file(self) -> str:
        return render_config_file(
            logging_level=self._charm_config.logging_level,
            db_path=f"{CONFIG_PATH}/core.db",
            n2_interface=N2_INTERFACE_NAME,
            n2_port=N2_PORT,
            n3_interface=N3_INTERFACE_NAME,
            n6_interface=N6_INTERFACE_NAME,
            api_interface=API_INTERFACE_NAME,
            api_port=API_PORT,
            api_tls_cert_path=f"{CONFIG_PATH}/cert.pem",
            api_tls_key_path=f"{CONFIG_PATH}/key.pem",
            xdp_attach_mode=XDP_ATTACH_MODE,
        )

    def _is_config_update_required(self, content: str) -> bool:
        if not self._config_file_is_written() or not self._config_file_content_matches(
            content=content
        ):
            return True
        return False

    def _push_config_file(self, content: str) -> None:
        self.container.push(path=CONFIG_FILE_PATH, source=content)
        logger.info("Config file written to %s", CONFIG_FILE_PATH)

    def _config_file_is_written(self) -> bool:
        return bool(self.container.exists(CONFIG_FILE_PATH))

    def _config_file_content_matches(self, content: str) -> bool:
        if not self.container.exists(path=CONFIG_FILE_PATH):
            return False
        existing_content = self.container.pull(path=CONFIG_FILE_PATH)
        if existing_content.read() != content:
            return False
        return True

    @property
    def _pebble_layer(self) -> Layer:
        """Return a dictionary representing a Pebble layer."""
        return Layer(
            {
                "summary": "Ella Core layer",
                "description": "pebble config layer for Ella Core",
                "services": {
                    "core": {
                        "override": "replace",
                        "summary": "Ella Core Service",
                        "command": "core --config /etc/core/core.yaml",
                        "startup": "enabled",
                    }
                },
            }
        )

    @property
    def _pod_name(self) -> str:
        """Name of the unit's pod.

        Returns:
            str: A string containing the name of the current unit's pod.
        """
        return "-".join(self.model.unit.name.rsplit("/", 1))

    def get_ingress_address(self) -> str | None:
        """Get the ingress address for the given relation."""
        relations = self.model.relations.get(PEER_RELATION_NAME, [])
        if not relations:
            return None
        if len(relations) > 1:
            logger.warning("More than one relation found")
        relation = relations[0]
        binding = self.model.get_binding(relation)
        if not binding or not binding.network.ingress_address:
            return None
        return str(binding.network.ingress_address)


if __name__ == "__main__":  # pragma: nocover
    main(EllaK8SCharm)  # type: ignore
